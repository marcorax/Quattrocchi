%% Parvo neurons, it refines the disparity computation from Magno neurons 
% while producing a dense estimantion.

clear all
clc;
addpath Functions
addpath Filters

%Settings and Data

NOrient=8; % number of oriented cells, FIXED the use of pre computed linear
           % filters to compute the gabor parvo cells.
           % Note that this number CANNOT differ from the same paramater set 
           % for the Magno simple neurons, therefore before computing the M
           % pathway check if it is = 8, in future works this limitation might
           % be removed, thus the code in the magno path is written to accept
           % any number of orientations while being fixed on 8 
           
timeOffs=0.001; % The two pathways need to exchange information when they 
                % are temporally sinchronised, thus i compute disparity 
                % from the Magno_Pathway using events coming from a time
                % window long 2*timeOffs centered at each frame timestamps

% The resolution of the sensor
xRes = 240;
yRes = 180;

% The Magno pathway simulation on Brian2 requires a lot of time, therefore
% only a small centered portion of the image is computed, which borders are 
% defined below (The code is meant ti work only with even values):
xInputSize = 40;
yInputSize = 80;

Dataset = '/Moving_Bar';
FramesFolder = '../Data/Extracted_Frames';
SpikesFolder = '../Data/Parvo_Population_Data' ;
load([FramesFolder Dataset '/FramesL.mat']); %Loading FrameL matrices
load([FramesFolder Dataset '/FramesR.mat']); %Loading FrameR matrices
load([FramesFolder Dataset '/Frametime.mat']); %Loading timeL and timeR arrays
load([SpikesFolder '/Input_On_' Dataset(2:end) '.mat']);
load([SpikesFolder '/Input_Off_' Dataset(2:end) '.mat']);

% On and off populations, previously computed in the Magno Pathway
OnPop = {OnPop0,OnPop1,OnPop2,OnPop3,OnPop4,OnPop5,OnPop6,OnPop7};
clear OnPop0 OnPop1 OnPop2 OnPop3 OnPop4 OnPop5 OnPop6 OnPop7
OnPopt = {OnPop0t,OnPop1t,OnPop2t,OnPop3t,OnPop4t,OnPop5t,OnPop6t,OnPop7t};
clear OnPop0t OnPop1t OnPop2t OnPop3t OnPop4t OnPop5t OnPop6t OnPop7t
OffPop = {OffPop0,OffPop1,OffPop2,OffPop3,OffPop4,OffPop5,OffPop6,OffPop7};
clear OffPop0 OffPop1 OffPop2 OffPop3 OffPop4 OffPop5 OffPop6 OffPop7
OffPopt = {OffPop0t,OffPop1t,OffPop2t,OffPop3t,OffPop4t,OffPop5t,OffPop6t,OffPop7t};
clear OffPop0t OffPop1t OffPop2t OffPop3t OffPop4t OffPop5t OffPop6t OffPop7t
timeL = double(timeL)/1000000;
timeR = double(timeR)/1000000;

% I concatenate the Frames and resize them to focus the computation only 
% within the borders defined with xInputSize and yInputSize
cutFramesL = cat(3,FramesL{:});
cutFramesR = cat(3,FramesR{:});
cutFramesL = cutFramesL((yRes/2)-(yInputSize/2)+1:(yRes/2)+(yInputSize/2),...
                                (xRes/2)-(xInputSize/2)+1:(xRes/2)+(xInputSize/2),:);
cutFramesR = cutFramesR((yRes/2)-(yInputSize/2)+1:(yRes/2)+(yInputSize/2),...
                                (xRes/2)-(xInputSize/2)+1:(xRes/2)+(xInputSize/2),:);

%% P_Pathway segmentation
% To avoid errors of interpolation performed by the segment below, the
% surfaces are segmentred with the informations extracted from the frames

% Number of iteration of the filling algorithm.
nIterations = 50;
% The border thikness (the size of each point generated by the active neurons
% in the mask used by activecontour)
bord_thick = 2;

tic;
[seg_frames_l,seg_frames_r] = segmentate(cutFramesL, cutFramesR, OnPop, OnPopt,...
                            OffPop, OffPopt, timeL, timeOffs, NOrient, ...
                            nIterations, bord_thick);
toc
%% M_Surface 
% Computing the disparity surfaces with information coming from the m_pathway.
% This solution is obtained decoding disparity from the magno cells
% activity, a solution that ease the work done in this path but is not biological
% plausible. In future works, a bioinspired technique should be implemented. 
% The surfaces are then segmented using the results from the P_Pathawy
% segmentation, only in respect to the left frame, if anything close to
% this computation is happening in the brain I find difficult to believe, 
% that the computation might happen unilateral as here. But probably
% informations are merged and reinforced building disparity surfaces
% respective for both eyes.

tic;
spkThr=3;
borders='linear';
[Coarse_h_disparity, Coarse_v_disparity, ScatterPerimeter] = m_surface(OnPop,...
                                        OnPopt, OffPop, OffPopt, timeL,...
                                        timeOffs, NOrient, spkThr, ...
                                        borders, seg_frames_l);
toc
%% Parvo population disparity computation and refining
tic;
% Polpulation settings
n_scales = 1;           % NUMBER OF SCALE - SET ON IMAGE SIZE AND DISPARITY CONTENT: max scale number n_scale, so that (minimum image size) / (2^n_scale) > (2*filter_size)
                        %                                                            max disparity decoded = +/- [2^n_scales /(4*0.063)]
energy_th = 2.2e-5;     % ENERGY THRESHOLD - SET ON DISPARITY RESULT
n_filters = 8;          % FIXED (To remember that the number cannot be set)
ori_thr = 0;            % FIXED

% Receptive field sizes (Select by commenting the unwanted one)
% FILTER 11x11 
ph_shift_file='FILTERS/ph_shift_PH7_F0.25.mat';
filter_file='FILTERS/Gt11B0.0833f0.25.mat';
% % FILTER 43x43
% filter='FILTERS/Gt43B0.0208f0.063.mat';
% ph_shift='FILTERS/ph_shift_PH7_F0.063.mat';

% Preparing data for P_Disparity function
II=cat(4,double(cutFramesL),double(cutFramesR));
mask=cat(4,seg_frames_l,seg_frames_r);
coarse_disp=cat(4,Coarse_h_disparity,Coarse_v_disparity);

% Computing refined disparity
fine_disp = P_Disparity(II,coarse_disp,mask,energy_th,ori_thr,ph_shift_file,filter_file);    

toc

%% Tests
% TODO prepare plots, morphs, tests and compute a new database
inputsize = size(seg_frames_l);
[xq,yq]=meshgrid(1:inputsize(2),1:inputsize(1));
frame = 93;
figure;
refined_solution=fine_disp{frame}(:,:,1)+coarse_disp(:,:,frame,1);
mesh(xq,yq,refined_solution);
figure;
mesh(xq,yq,coarse_disp(:,:,frame,1));


